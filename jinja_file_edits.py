#!/usr/bin/env python2

import subprocess
from jinja2 import Environment, FileSystemLoader, PackageLoader, Template, tests
from redhawk.codegen.jinja.environment import CodegenEnvironment
from os.path import join, exists, getmtime, dirname
from redhawk.codegen.jinja.python.component.gr_flowgraph import PullComponentGenerator

# ##############################################################################
# TODO: This code was changed from its original form, and the
#       "modify_make_am_ide" method needs to occur after the redhawk-codegen,
#       however the "modify_resource" method needs to occur beforehand.

def main(output_dir, py_file, py_name, properties, rp, pd):
    # modify_make_am_ide(output_dir, py_file) # TODO: This call needs to occur after codegen
    modify_resource(output_dir, py_file, py_name, properties, rp, pd)

# ##############################################################################
# This method simply takes the "Mafefile.am.ide" file that is generated by
# a call to "redhawk-codegen" and appends one extra line to the end, so that
# the "top_block.py" (or other named python file generated earlier from the
# user-provided GRC) file is accessible. This append action is nescessary since
# it is not possible to inherit (and subsequently add content) from the original
# jinja template file that creates the "Makefile.am.ide" file.
# ##############################################################################
def modify_make_am_ide(output_dir, py_file):

    full_path = output_dir + "Makefile.am.ide"
    output = "redhawk_SCRIPTS_auto += %s" % py_file

    with open(full_path, "a") as o_file:
        o_file.write("redhawk_SCRIPTS_auto += top_block.py")


# ##############################################################################
# TODO: Finish description. Remove hard coding of templates directory path.
#
# TODO: RUN END RESULTING TEMPLATE AGAINST THE "FlowGraphPrototype.py" using
#       the "vimdiff" command to determine if there are any spelling mistakes
#       or other syntactical descrepencies that would cause the template to
#       break/crash.
# ##############################################################################
def modify_resource(output_dir, py_file, py_name, properties, rp, ports_data):

    count = 0

    rm_py = py_file.split(".")[0]
    template_dir = "/usr/local/redhawk/core/lib/python/redhawk/codegen/jinja/python/component/gr_flowgraph/templates/"

    env = Environment(loader=FileSystemLoader(template_dir))
    rs_file = template_dir + "resource_build.py"

    # template = env.get_template("resource_child.py")
    # output = template.render(topblock=rm_py)

    subprocess.call(["touch", rs_file])

    with open(rs_file, "w") as f:

        f.write("#% extends \"resource_parent.py\" \n")
        f.write("#{% block topblockimport %}")
        f.write("from %s import %s\n" % (rm_py, rm_py))
        f.write("#{% endblock %}\n\n")

        if properties:
            f.write("\n#{% block addpropertychangelisteners %}\n")              # Watch out for the needed newline at the beginning of the string here or Jinja will blow up

            for prop in properties:
                count += 1                                                      # I don't know of a way to correct tab formatting, so I'm doing this for now
                format_property_change_listeners(prop, f, count)
            f.write("#{% endblock %}\n\n")

            # ##################################################################
            # I do not think that both of these generations could occur within
            # the same for loop, but I could be wrong...
            # ##################################################################
            f.write("#{% block propertychanged %}\n")
            count = 0

            for prop in properties:
                count += 1
                format_property_changed(prop, f, count)
            f.write("#{% endblock %}\n")

        base = py_name + "_base"

        f.write("#{% block start %}\n")
        f.write("%s.start(self)\n" % base)
        f.write("#{% endblock %}\n")

        f.write("#{% block stop %}\n")
        f.write("%s.stop(self)\n" % base)
        f.write("#{% endblock %}\n")

        f.write("#{% block getport %}\n")
        count = 0

        for port in ports_data:
            count += 1
            format_ports_data(port, f, count)
        f.write("#{% endblock %}")

def format_property_change_listeners(prop, f, count):

    new_id = "gr::" + prop.name
    new_name = "gr_" + prop.name

    property_changed = new_name + "_changed"

    # ##########################################################################
    # First iteration, first statement of propertychangelisteners gets tabbed,
    # all subsequent lines do not, and correct formatting needs to be maintained
    # so this conditional and the followed tabbed statement are necessary.
    #
    # TODO: Test this formatting with a Flow Graph that contains more than one
    #       property to ensure correct formatting is retained.
    # ##########################################################################
    if count != 1:
        f.write("\t\t")

    f.write("self.addPropertyChangeListener(\'%s\', self.%s)\n" % (new_id, property_changed))
    f.write("\t\tself.%s(\'%s\', 0, self.%s)\n" % (property_changed, new_id, new_name))

def format_property_changed(prop, f, count):

    new_name = "gr_" + prop.name
    property_changed = new_name + "_changed"

    if count != 1:
        f.write("\t\t")

    f.write("def %s(self, id, old_value, new_value):\n\n" % property_changed)
    f.write("\t\tself.tb.set_%s(new_value)\n" % prop.name)
    f.write("\t\tself.%s = self.tb.get_%s()\n" % (new_name, prop.name))

def format_ports_data(port, f, count):

    if count != 1:
        f.write("\t\t")

    f.write("if name == \"%s\":\n" % port[1])
    f.write("\t\t\treturn self.tb.%s.getPort(\"%s\")\n" % (port[0], port[1]))
