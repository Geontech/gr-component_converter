import subprocess
from jinja2 import Environment, FileSystemLoader, PackageLoader, Template, tests
from redhawk.codegen.jinja.environment import CodegenEnvironment
from os.path import join, exists, getmtime, dirname

def main(py_file, py_name, properties, pd):
    modify_resource(py_file, py_name, properties, pd)

# ##############################################################################
# This method simply takes the "Mafefile.am.ide" file that is generated by
# a call to "redhawk-codegen" and appends one extra line to the end, so that
# the "top_block.py" (or other named python file generated earlier from the
# user-provided GRC) file is accessible. This append action is nescessary since
# it is not possible to inherit (and subsequently add content) from the original
# jinja template file that creates the "Makefile.am.ide" file.
# ##############################################################################
def modify_make_am_ide(output_dir, py_file):

    full_path = output_dir + "Makefile.am.ide"
    output = "redhawk_SCRIPTS_auto += %s" % py_file

    with open(full_path, "a") as o_file:
        o_file.write(output)


# ##############################################################################
# This method is used to "dynamically" create a child template, using a given
# GRC file's unique values, ports, properties, etc, which will eventually be
# ingested by the "resource_parent.py" template to create the end resource file.
# This method makes use of two other methods, which are necessary for adding
# multiple Jinja lines of the same format if the GRC file requires such.
#
# TODO: Remove hard coding of templates directory path. At this time, I am still
#       unsure about the end location of these templates in the Docker container
#
# TODO: RUN END RESULTING TEMPLATE AGAINST THE "FlowGraphPrototype.py" using
#       the "vimdiff" command to determine if there are any spelling mistakes
#       or other syntactical descrepencies that would cause the template to
#       break/crash.
# ##############################################################################
def modify_resource(py_file, py_name, properties, ports_data):

    count = 0

    rm_py = py_file.split(".")[0]
    template_dir = "/usr/local/redhawk/core/lib/python/redhawk/codegen/jinja/python/component/gr_flowgraph/templates/"

    env = Environment(loader=FileSystemLoader(template_dir))
    rs_file = template_dir + "resource_build.py"

    subprocess.call(["touch", rs_file])

    with open(rs_file, "w") as f:

        f.write("#% extends \"resource_parent.py\" \n")
        f.write("#{% block topblockimport %}")
        f.write("from %s import %s\n" % (rm_py, rm_py))
        f.write("#{% endblock %}\n\n")

        if properties:
            f.write("\n#{% block addpropertychangelisteners %}\n")              # Watch out for the needed newline at the beginning of the string here or Jinja will blow up
            f.write("def constructor(self):\n")

            for prop in properties:
                count += 1                                                      # I don't know of a way to correct tab formatting, so I'm doing this for now
                format_property_change_listeners(prop, f, count)
            f.write("#{% endblock %}\n\n")

            # ##################################################################
            # I do not think that both of these generations could occur within
            # the same for loop, but I could be wrong...
            # ##################################################################
            f.write("#{% block propertychanged %}\n")
            count = 0

            for prop in properties:
                count += 1
                format_property_changed(prop, f, count)
            f.write("#{% endblock %}\n")

        base = py_name + "_base"

        f.write("#{% block start %}\n")
        f.write("%s.start(self)\n" % base)
        f.write("#{% endblock %}\n")

        f.write("#{% block stop %}\n")
        f.write("%s.stop(self)\n" % base)
        f.write("#{% endblock %}\n")

        f.write("#{% block getport %}\n")
        count = 0

        for port in ports_data:
            count += 1
            format_ports_data(port, f, count)
        f.write("#{% endblock %}\n")

        f.write("#{% block startcomponent %}\n")
        f.write("start_component(${className})\n")
        f.write("#{% endblock %}")

def format_property_change_listeners(prop, f, count):

    new_id = "gr::" + prop.name
    new_name = "gr_" + prop.name

    property_changed = new_name + "_changed"

    # ##########################################################################
    # First iteration, first statement of propertychangelisteners gets tabbed,
    # all subsequent lines do not, and correct formatting needs to be maintained
    # so this conditional and the followed tabbed statement are necessary.
    # ##########################################################################

    f.write("        self.addPropertyChangeListener(\'%s\', self.%s)\n" % (new_id, property_changed))
    f.write("        self.%s(\'%s\', 0, self.%s)\n" % (property_changed, new_id, new_name))

def format_property_changed(prop, f, count):

    new_name = "gr_" + prop.name
    property_changed = new_name + "_changed"

    if count != 1:
        f.write("        def %s(self, id, old_value, new_value):\n" % property_changed)
    else:
        f.write("def %s(self, id, old_value, new_value):\n" % property_changed)

    f.write("        self.tb.set_%s(new_value)\n" % prop.name)
    f.write("        self.%s = self.tb.get_%s()\n" % (new_name, prop.name))


# ##############################################################################
# TODO: I worry that the second passed variable into the 3rd f.write statement
#       ("f.write("            return self.tb.%s.getPort(\"%s\")\n" % (port[0],
#       port[1]))") may not be correct. Judging from Drew's files, this is my
#       best geuss if you will.
# ##############################################################################
def format_ports_data(port, f, count):

    if count != 1:
        f.write("        if name == \"%s\":\n" % port[1])
    else:
        f.write("if name == \"%s\":\n" % port[1])

    f.write("            return self.tb.%s.getPort(\"%s\")\n" % (port[0], port[1]))
